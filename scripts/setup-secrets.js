#!/usr/bin/env node

/**
 * FieldSync Secret Management Setup Script
 * Helps initialize and manage application secrets securely
 */

const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const readline = require('readline');

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

// Utility functions
const log = (color, message) => console.log(`${color}${message}${colors.reset}`);
const success = (message) => log(colors.green, `âœ… ${message}`);
const error = (message) => log(colors.red, `âŒ ${message}`);
const warning = (message) => log(colors.yellow, `âš ï¸  ${message}`);
const info = (message) => log(colors.blue, `â„¹ï¸  ${message}`);
const header = (message) => log(colors.cyan, `\nðŸ” ${message}`);

// Create readline interface
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Promisify readline question
const question = (query) => new Promise(resolve => rl.question(query, resolve));

// Secret definitions with metadata
const secretDefinitions = {
  'JWT_SECRET': {
    description: 'Primary JWT signing secret',
    required: true,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'REFRESH_SECRET': {
    description: 'JWT refresh token secret',
    required: true,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'CSRF_SECRET': {
    description: 'CSRF protection secret',
    required: true,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'ENCRYPTION_KEY': {
    description: 'Data encryption master key',
    required: false,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'DATABASE_PASSWORD': {
    description: 'Database connection password',
    required: false,
    minLength: 12,
    generator: () => generatePassword(16)
  },
  'REDIS_PASSWORD': {
    description: 'Redis connection password',
    required: false,
    minLength: 12,
    generator: () => generatePassword(16)
  },
  'SMTP_PASSWORD': {
    description: 'SMTP authentication password',
    required: false,
    minLength: 8,
    generator: null // Usually provided by email service
  },
  'API_ENCRYPTION_KEY': {
    description: 'API payload encryption key',
    required: false,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'WEBHOOK_SECRET': {
    description: 'Webhook signature verification secret',
    required: false,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  },
  'SESSION_SECRET': {
    description: 'Session encryption secret',
    required: false,
    minLength: 32,
    generator: () => crypto.randomBytes(32).toString('hex')
  }
};

// Password generator with complexity requirements
function generatePassword(length = 16) {
  const lowercase = 'abcdefghijklmnopqrstuvwxyz';
  const uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  const numbers = '0123456789';
  const symbols = '!@#$%^&*()_+-=[]{}|;:,.<>?';
  
  const all = lowercase + uppercase + numbers + symbols;
  let password = '';
  
  // Ensure at least one character from each set
  password += lowercase[Math.floor(Math.random() * lowercase.length)];
  password += uppercase[Math.floor(Math.random() * uppercase.length)];
  password += numbers[Math.floor(Math.random() * numbers.length)];
  password += symbols[Math.floor(Math.random() * symbols.length)];
  
  // Fill the rest randomly
  for (let i = 4; i < length; i++) {
    password += all[Math.floor(Math.random() * all.length)];
  }
  
  // Shuffle the password
  return password.split('').sort(() => Math.random() - 0.5).join('');
}

// Load existing .env file
function loadEnvFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return {};
  }
  
  const content = fs.readFileSync(filePath, 'utf8');
  const env = {};
  
  content.split('\n').forEach(line => {
    const match = line.match(/^([^#][^=]+)=(.*)$/);
    if (match) {
      env[match[1].trim()] = match[2].trim();
    }
  });
  
  return env;
}

// Save .env file
function saveEnvFile(filePath, env) {
  const lines = [];
  
  // Add header
  lines.push('# FieldSync Application Secrets');
  lines.push('# Generated by setup-secrets.js');
  lines.push(`# Generated at: ${new Date().toISOString()}`);
  lines.push('');
  
  // Add secrets
  Object.entries(env).forEach(([key, value]) => {
    lines.push(`${key}=${value}`);
  });
  
  fs.writeFileSync(filePath, lines.join('\n'));
  
  // Set restrictive permissions
  try {
    fs.chmodSync(filePath, 0o600); // Read/write for owner only
  } catch (e) {
    warning('Could not set restrictive permissions on .env file');
  }
}

// Validate secret strength
function validateSecret(key, value) {
  const definition = secretDefinitions[key];
  if (!definition) return { valid: true, message: '' };
  
  if (definition.minLength && value.length < definition.minLength) {
    return {
      valid: false,
      message: `${key} must be at least ${definition.minLength} characters long`
    };
  }
  
  // Check for common weak patterns
  const weakPatterns = [
    'password',
    '123456',
    'admin',
    'secret',
    'changeme',
    'default'
  ];
  
  const lowerValue = value.toLowerCase();
  for (const pattern of weakPatterns) {
    if (lowerValue.includes(pattern)) {
      return {
        valid: false,
        message: `${key} appears to contain weak/common patterns`
      };
    }
  }
  
  return { valid: true, message: '' };
}

// Interactive secret setup
async function setupSecretsInteractively() {
  header('Interactive Secret Setup');
  
  console.log('This will help you set up secure secrets for FieldSync.\n');
  
  const envPath = path.join(__dirname, '../backend/.env');
  const existingEnv = loadEnvFile(envPath);
  const newEnv = { ...existingEnv };
  
  for (const [key, definition] of Object.entries(secretDefinitions)) {
    console.log(`\n${colors.cyan}${key}${colors.reset}`);
    console.log(`Description: ${definition.description}`);
    console.log(`Required: ${definition.required ? 'Yes' : 'No'}`);
    
    if (existingEnv[key]) {
      console.log(`Current value: ${colors.yellow}[SET]${colors.reset}`);
      const keepExisting = await question(`Keep existing value? (Y/n): `);
      if (keepExisting.toLowerCase() !== 'n') {
        continue;
      }
    }
    
    let value = '';
    
    if (definition.generator) {
      const autoGenerate = await question(`Auto-generate secure value? (Y/n): `);
      if (autoGenerate.toLowerCase() !== 'n') {
        value = definition.generator();
        success('Generated secure value');
      }
    }
    
    if (!value) {
      value = await question(`Enter value for ${key}: `);
    }
    
    if (value) {
      const validation = validateSecret(key, value);
      if (!validation.valid) {
        error(validation.message);
        const continueAnyway = await question('Use this value anyway? (y/N): ');
        if (continueAnyway.toLowerCase() !== 'y') {
          continue;
        }
      }
      
      newEnv[key] = value;
      success(`${key} configured`);
    } else if (definition.required) {
      warning(`${key} is required but no value provided`);
    }
  }
  
  // Save the updated environment file
  saveEnvFile(envPath, newEnv);
  success(`Secrets saved to ${envPath}`);
  
  return newEnv;
}

// Batch secret generation
async function generateAllSecrets() {
  header('Batch Secret Generation');
  
  const envPath = path.join(__dirname, '../backend/.env');
  const existingEnv = loadEnvFile(envPath);
  const newEnv = { ...existingEnv };
  
  let generatedCount = 0;
  
  for (const [key, definition] of Object.entries(secretDefinitions)) {
    if (definition.generator && !existingEnv[key]) {
      newEnv[key] = definition.generator();
      success(`Generated ${key}`);
      generatedCount++;
    }
  }
  
  if (generatedCount > 0) {
    saveEnvFile(envPath, newEnv);
    success(`Generated ${generatedCount} secrets and saved to ${envPath}`);
  } else {
    info('No new secrets to generate (all already exist)');
  }
  
  return newEnv;
}

// Rotate existing secrets
async function rotateSecrets() {
  header('Secret Rotation');
  
  const envPath = path.join(__dirname, '../backend/.env');
  const existingEnv = loadEnvFile(envPath);
  
  console.log('Available secrets to rotate:');
  const rotatableSecrets = Object.keys(secretDefinitions).filter(key => 
    existingEnv[key] && secretDefinitions[key].generator
  );
  
  if (rotatableSecrets.length === 0) {
    warning('No rotatable secrets found');
    return;
  }
  
  rotatableSecrets.forEach((key, index) => {
    console.log(`${index + 1}. ${key} - ${secretDefinitions[key].description}`);
  });
  
  const selection = await question('\nEnter numbers to rotate (comma-separated) or "all": ');
  
  let toRotate = [];
  if (selection.toLowerCase() === 'all') {
    toRotate = rotatableSecrets;
  } else {
    const indices = selection.split(',').map(s => parseInt(s.trim()) - 1);
    toRotate = indices.map(i => rotatableSecrets[i]).filter(Boolean);
  }
  
  if (toRotate.length === 0) {
    warning('No valid secrets selected for rotation');
    return;
  }
  
  const confirm = await question(`\nThis will rotate ${toRotate.length} secret(s). Continue? (y/N): `);
  if (confirm.toLowerCase() !== 'y') {
    info('Rotation cancelled');
    return;
  }
  
  const newEnv = { ...existingEnv };
  
  toRotate.forEach(key => {
    const oldValue = existingEnv[key];
    const newValue = secretDefinitions[key].generator();
    newEnv[key] = newValue;
    success(`Rotated ${key}`);
    
    // Log rotation event (without showing actual values)
    console.log(`  Old: ${oldValue.substring(0, 8)}...`);
    console.log(`  New: ${newValue.substring(0, 8)}...`);
  });
  
  // Create backup of old env file
  const backupPath = `${envPath}.backup.${Date.now()}`;
  fs.copyFileSync(envPath, backupPath);
  success(`Backup created: ${backupPath}`);
  
  saveEnvFile(envPath, newEnv);
  success('Secret rotation completed');
  
  warning('Remember to restart your application to use the new secrets!');
}

// Validate current secrets
async function validateCurrentSecrets() {
  header('Secret Validation');
  
  const envPath = path.join(__dirname, '../backend/.env');
  const env = loadEnvFile(envPath);
  
  if (Object.keys(env).length === 0) {
    error('No environment file found');
    return;
  }
  
  let validCount = 0;
  let warningCount = 0;
  let errorCount = 0;
  
  for (const [key, definition] of Object.entries(secretDefinitions)) {
    const value = env[key];
    
    if (definition.required && !value) {
      error(`Required secret ${key} is missing`);
      errorCount++;
      continue;
    }
    
    if (value) {
      const validation = validateSecret(key, value);
      if (validation.valid) {
        success(`${key} is valid`);
        validCount++;
      } else {
        warning(`${key}: ${validation.message}`);
        warningCount++;
      }
    }
  }
  
  console.log(`\nðŸ“Š Validation Summary:`);
  console.log(`   âœ… Valid: ${colors.green}${validCount}${colors.reset}`);
  console.log(`   âš ï¸  Warnings: ${colors.yellow}${warningCount}${colors.reset}`);
  console.log(`   âŒ Errors: ${colors.red}${errorCount}${colors.reset}`);
  
  if (errorCount > 0) {
    warning('Application may not start properly with missing required secrets');
  } else if (warningCount > 0) {
    warning('Consider improving weak secrets for better security');
  } else {
    success('All secrets are properly configured!');
  }
}

// Export secrets (securely)
async function exportSecrets() {
  header('Secret Export');
  
  warning('This will export secrets to a file. Use with caution!');
  const confirm = await question('Continue? (y/N): ');
  if (confirm.toLowerCase() !== 'y') {
    info('Export cancelled');
    return;
  }
  
  const envPath = path.join(__dirname, '../backend/.env');
  const env = loadEnvFile(envPath);
  
  const outputPath = path.join(__dirname, `../secrets-export-${Date.now()}.json`);
  
  // Filter out non-secret environment variables
  const secrets = {};
  Object.keys(secretDefinitions).forEach(key => {
    if (env[key]) {
      secrets[key] = env[key];
    }
  });
  
  fs.writeFileSync(outputPath, JSON.stringify(secrets, null, 2));
  fs.chmodSync(outputPath, 0o600);
  
  success(`Secrets exported to ${outputPath}`);
  warning('Delete this file after use and never commit it to version control!');
}

// Main menu
async function showMenu() {
  console.log(`${colors.cyan}FieldSync Secret Management${colors.reset}\n`);
  console.log('1. Interactive secret setup');
  console.log('2. Generate all missing secrets');
  console.log('3. Rotate existing secrets');
  console.log('4. Validate current secrets');
  console.log('5. Export secrets (use with caution)');
  console.log('6. Exit\n');
  
  const choice = await question('Select an option (1-6): ');
  
  switch (choice) {
    case '1':
      await setupSecretsInteractively();
      break;
    case '2':
      await generateAllSecrets();
      break;
    case '3':
      await rotateSecrets();
      break;
    case '4':
      await validateCurrentSecrets();
      break;
    case '5':
      await exportSecrets();
      break;
    case '6':
      success('Goodbye!');
      rl.close();
      return;
    default:
      warning('Invalid option. Please try again.');
  }
  
  console.log('\n');
  const continueUsing = await question('Return to menu? (Y/n): ');
  if (continueUsing.toLowerCase() !== 'n') {
    await showMenu();
  } else {
    rl.close();
  }
}

// Handle command line arguments
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    await showMenu();
    return;
  }
  
  const command = args[0];
  
  switch (command) {
    case 'generate':
      await generateAllSecrets();
      break;
    case 'validate':
      await validateCurrentSecrets();
      break;
    case 'rotate':
      await rotateSecrets();
      break;
    case 'interactive':
      await setupSecretsInteractively();
      break;
    case 'export':
      await exportSecrets();
      break;
    default:
      console.log('Usage: node setup-secrets.js [command]');
      console.log('Commands: generate, validate, rotate, interactive, export');
      console.log('Run without arguments for interactive menu');
  }
  
  rl.close();
}

// Run the script
main().catch(error => {
  console.error(`${colors.red}Error: ${error.message}${colors.reset}`);
  rl.close();
  process.exit(1);
});